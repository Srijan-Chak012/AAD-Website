<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>Algorithms, Analysis and Design</title>

    <link rel="stylesheet" href="../../assets/vendor/animate/animate.css">

    <link rel="stylesheet" href="../../assets/css/bootstrap.css">

    <link rel="stylesheet" href="../../assets/css/maicons.css">

    <link rel="stylesheet" href="../../assets/vendor/owl-carousel/css/owl.carousel.css">

    <link rel="stylesheet" href="../../assets/css/theme.css">

</head>

<body>

    <!-- Back to top button -->
    <div class="back-to-top"></div>

    <nav class="navbar navbar-expand-lg navbar-light navbar-float">
        <div class="container">
            <a href="../../index.html" class="navbar-brand">Algorithms, Analysis and Design</a>

            <button class="navbar-toggler" data-toggle="collapse" data-target="#navbarContent"
                aria-controls="navbarContent" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>

            <div class="navbar-collapse collapse" id="navbarContent">
                <ul class="navbar-nav ml-lg-4 pt-3 pt-lg-0">
                    <li class="nav-item">
                        <a href="../../index.html" class="nav-link">Home</a>
                    </li>
                    <li class="nav-item active">
                        <a href="../Algorithms.html" class="nav-link">Algorithms</a>
                    </li>
                    <li class="nav-item">
                        <a href="../Music.html" class="nav-link">Music Project</a>
                    </li>
                    <li class="nav-item">
                        <a href="../Crypto.html" class="nav-link">Cryptography</a>
                    </li>
                </ul>

                <div class="ml-auto">
                    <a href="https://srijan-chak012.github.io/Website/" class="btn btn-outline rounded-pill">Want to
                        know more about me?</a>
                </div>
            </div>
        </div>
    </nav>

    <div class="page-banner home-banner">
        <div class="container h-150">
            <!-- <div class="row align-items-center h-150">
                <div class="col-lg-6 py-3 wow fadeInUp"> -->
            <br><br><br><br>
            <h2 class="mb-4">Sorting Algorithms</h2>
            <h4 class="mb-4">Dijkstra's Algorithm</h4>
            <p class="text-lg mb-5">
                Dijkstra's algorithm is a method for determining the shortest pathways between nodes in a graph, which
                might represent a road network. The algorithm calculates the shortest path between any two nodes in the
                network for a given source node. It may also be used to find the shortest pathways from a single node to
                a single destination node by halting the process once the shortest path to the target node is found.
                <br><br>
                For example, if the graph's nodes represent cities and edge path costs represent driving distances
                between
                pairs of cities connected by a direct road (ignoring red lights, stop signs, toll roads, and other
                obstructions for simplicity), Dijkstra's algorithm can be used to find the shortest route between one
                city and all other cities.
                <br><br>
                Dijkstra's algorithm uses a data structure for storing and querying partial solutions sorted by distance
                from the start. While the original algorithm uses a min-priority queue and runs in time Θ((|V|+|E|)log
                |V|) (where |V| is the number of nodes and |E| is the number of edges), it can also be implemented in
                Θ(|V|^{2})(|V|^{2}) using an array.
                <br><br>
                Algorithm: <br>
                Let the node at which we are starting at be called the initial node. Let the distance of node Y be the
                distance from the initial node to Y. Dijkstra's algorithm will initially start with infinite distances
                and will try to improve them step by step. <br><br>

                1. Mark all nodes unvisited. Create a set of all the unvisited nodes called the unvisited set. <br>
                2. Assign to every node a tentative distance value: set it to zero for our initial node and to infinity
                for
                all other nodes. The tentative distance of a node v is the length of the shortest path discovered so far
                between the node v and the starting node. Since initially no path is known to any other vertex than the
                source itself (which is a path of length zero), all other tentative distances are initially set to
                infinity. Set the initial node as current.<br>
                3. For the current node, consider all of its unvisited neighbors and calculate their tentative distances
                through the current node. Compare the newly calculated tentative distance to the current assigned value
                and assign the smaller one. For example, if the current node A is marked with a distance of 6, and the
                edge connecting it with a neighbor B has length 2, then the distance to B through A will be 6 + 2 = 8.
                If B was previously marked with a distance greater than 8 then change it to 8. Otherwise, the current
                value will be kept. <br>
                4. When we are done considering all of the unvisited neighbors of the current node, mark the current
                node
                as visited and remove it from the unvisited set. A visited node will never be checked again.<br>
                5. If the destination node has been marked visited (when planning a route between two specific nodes) or
                if
                the smallest tentative distance among the nodes in the unvisited set is infinity (when planning a
                complete traversal; occurs when there is no connection between the initial node and remaining unvisited
                nodes), then stop. The algorithm has finished.<br>
                6. Otherwise, select the unvisited node that is marked with the smallest tentative distance, set it as
                the
                new current node, and go back to step 3.<br>
                When planning a route, it is actually not necessary to wait until the destination node is "visited" as
                above: the algorithm can stop once the destination node has the smallest tentative distance among all
                "unvisited" nodes (and thus could be selected as the next "current").<br><br>
            </p>

            <h4 class="mb-4">Kruskal's Algorithm</h4>
            <p class="text-lg mb-5">
                Kruskal's algorithm finds a minimum spanning forest of an undirected edge-weighted graph. If the graph
                is connected, it finds a minimum spanning tree. (A minimum spanning tree of a connected graph is a
                subset of the edges that forms a tree that includes every vertex, where the sum of the weights of all
                the edges in the tree is minimized. For a disconnected graph, a minimum spanning forest is composed of a
                minimum spanning tree for each connected component.) It is a greedy algorithm in graph theory as in each
                step it adds the next lowest-weight edge that will not form a cycle to the minimum spanning forest.
                <br><br>
                Algorithm:<br>
                1. create a forest F (a set of trees), where each vertex in the graph is a separate tree <br>
                2. create a set S containing all the edges in the graph <br>
                3. while S is nonempty and F is not yet spanning <br>
                &emsp;&emsp;remove an edge with minimum weight from S<br>
                &emsp;&emsp;if the removed edge connects two different trees then add it to the forest F, combining two
                trees into a single tree<br>
                At the termination of the algorithm, the forest forms a minimum spanning forest of the graph. If the
                graph is connected, the forest has a single component and forms a minimum spanning tree.
                <br><br>

                Pseudocode:<br>

                The following code is implemented with a disjoint-set data structure. Here, we represent our forest F as
                a set of edges, and use the disjoint-set data structure to efficiently determine whether two vertices
                are part of the same tree.<br>
                algorithm Kruskal(G) is<br>
                F:= ∅<br>
                for each v ∈ G.V do<br>
                MAKE-SET(v)<br>
                for each (u, v) in G.E ordered by weight(u, v), increasing do<br>
                if FIND-SET(u) ≠ FIND-SET(v) then<br>
                F:= F ∪ {(u, v)} ∪ {(v, u)}<br>
                UNION(FIND-SET(u), FIND-SET(v))<br>
                return F
                <br><br>
                For a graph with E edges and V vertices, Kruskal's algorithm can be shown to run in O(E log E) time, or
                equivalently, O(E log V) time, all with simple data structures. These running times are equivalent
                because:<br>

                1. E is at most V^{2} and log V^{2} = 2 log V in O(logV)<br>
                2. Each isolated vertex is a separate component of the minimum spanning forest. If we ignore isolated
                vertices we obtain V ≤ 2E, so log V is O(log E).
                <br><br>
            </p>
            <h4 class="mb-4">Prim's Algorithm</h4>
            <p class="text-lg mb-5">
                Prim's algorithm is a greedy algorithm that finds a minimum spanning tree for a weighted undirected
                graph. This means it finds a subset of the edges that forms a tree that includes every vertex, where the
                total weight of all the edges in the tree is minimized. The algorithm operates by building this tree one
                vertex at a time, from an arbitrary starting vertex, at each step adding the cheapest possible
                connection from the tree to another vertex.
                <br><br>
                Algorithm:<br>
                1. Initialize a tree with a single vertex, chosen arbitrarily from the graph.<br>
                2. Grow the tree by one edge: of the edges that connect the tree to vertices not yet in the tree, find
                the
                minimum-weight edge, and transfer it to the tree. <br>
                3. Repeat step 2 (until all vertices are in the tree). <br><br>
                Pseudocode:<br>
                1. Associate with each vertex v of the graph a number C[v] (the cheapest cost of a connection to v) and
                an
                edge E[v] (the edge providing that cheapest connection). To initialize these values, set all values of
                C[v] to +∞ (or to any number larger than the maximum edge weight) and set each E[v] to a special flag
                value indicating that there is no edge connecting v to earlier vertices.<br>
                2. Initialize an empty forest F and a set Q of vertices that have not yet been included in F (initially,
                all vertices).<br>
                3. Repeat the following steps until Q is empty:<br>
                &emsp;&emsp;Find and remove a vertex v from Q having the minimum possible value of C[v]<br>
                &emsp;&emsp;Add v to F and, if E[v] is not the special flag value, also add E[v] to F<br>
                &emsp;&emsp;Loop over the edges vw connecting v to other vertices w. For each such edge, if w still
                belongs to Q and
                vw has smaller weight than &emsp;&emsp;C[w], perform the following steps:<br>
                &emsp;&emsp;&emsp;&emsp;Set C[w] to the cost of edge vw<br>
                &emsp;&emsp;&emsp;&emsp;Set E[w] to point to edge vw.<br>
                4. Return F
                <br><br>
                As described above, the starting vertex for the algorithm will be chosen arbitrarily, because the first
                iteration of the main loop of the algorithm will have a set of vertices in Q that all have equal
                weights, and the algorithm will automatically start a new tree in F when it completes a spanning tree of
                each connected component of the input graph. The algorithm may be modified to start with any particular
                vertex s by setting C[s] to be a number smaller than the other values of C (for instance, zero), and it
                may be modified to only find a single spanning tree rather than an entire spanning forest (matching more
                closely the informal description) by stopping whenever it encounters another vertex flagged as having no
                associated edge.<br><br>

                Different variations of the algorithm differ from each other in how the set Q is implemented: as a
                simple linked list or array of vertices, or as a more complicated priority queue data structure. This
                choice leads to differences in the time complexity of the algorithm. In general, a priority queue will
                be quicker at finding the vertex v with minimum cost, but will entail more expensive updates when the
                value of C[w] changes.
                <br><br>

            </p>
            <!-- </div>
            </div> -->
        </div>
    </div>


    <script src="../../assets/js/jquery-3.5.1.min.js"></script>

    <script src="../../assets/js/bootstrap.bundle.min.js"></script>

    <script src="../../assets/vendor/wow/wow.min.js"></script>

    <script src="../../assets/vendor/owl-carousel/js/owl.carousel.min.js"></script>

    <script src="../../assets/vendor/waypoints/jquery.waypoints.min.js"></script>

    <script src="../../assets/vendor/animateNumber/jquery.animateNumber.min.js"></script>

    <script src="../../assets/js/google-maps.js"></script>

    <script src="../../assets/js/theme.js"></script>


</body>

</html>