<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>Algorithms, Analysis and Design</title>

    <link rel="stylesheet" href="../../assets/vendor/animate/animate.css">

    <link rel="stylesheet" href="../../assets/css/bootstrap.css">

    <link rel="stylesheet" href="../../assets/css/maicons.css">

    <link rel="stylesheet" href="../../assets/vendor/owl-carousel/css/owl.carousel.css">

    <link rel="stylesheet" href="../../assets/css/theme.css">

</head>

<body>

    <!-- Back to top button -->
    <div class="back-to-top"></div>

    <nav class="navbar navbar-expand-lg navbar-light navbar-float">
        <div class="container">
            <a href="../../index.html" class="navbar-brand">Algorithms, Analysis and Design</a>

            <button class="navbar-toggler" data-toggle="collapse" data-target="#navbarContent"
                aria-controls="navbarContent" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>

            <div class="navbar-collapse collapse" id="navbarContent">
                <ul class="navbar-nav ml-lg-4 pt-3 pt-lg-0">
                    <li class="nav-item">
                        <a href="../../index.html" class="nav-link">Home</a>
                    </li>
                    <li class="nav-item active">
                        <a href="../Algorithms.html" class="nav-link">Algorithms</a>
                    </li>
                    <li class="nav-item">
                        <a href="../Music.html" class="nav-link">Music Project</a>
                    </li>
                    <li class="nav-item">
                        <a href="../Crypto.html" class="nav-link">Cryptography</a>
                    </li>
                </ul>

                <div class="ml-auto">
                    <a href="https://srijan-chak012.github.io/Website/" class="btn btn-outline rounded-pill">Want to
                        know more about me?</a>
                </div>
            </div>
        </div>
    </nav>

    <div class="page-banner home-banner">
        <div class="container h-150">
            <!-- <div class="row align-items-center h-150">
                <div class="col-lg-6 py-3 wow fadeInUp"> -->
            <br><br><br><br>
            <h2 class="mb-4">Sorting Algorithms</h2>
            <h4 class="mb-4">Bubble Sort</h4>
            <p class="text-lg mb-5">
                Bubble sort, also known as sinking sort, is a basic sorting algorithm that passes over the list
                repeatedly, compares neighbouring members, and swaps them if they are out of order. The process of
                traversing the list is continued until the list is sorted. The comparison sort method is called from the
                way smaller or bigger entries "bubble" to the top of the list.<br><br>
                Pseudocode implementation<br>
                procedure bubbleSort(A : list of sortable items)<br>
                n := length(A)<br>
                repeat<br>
                swapped := false<br>
                for i := 1 to n-1 inclusive do<br>
                /* if this pair is out of order */<br>
                if A[i-1] > A[i] then<br>
                /* swap them and remember something changed */<br>
                swap(A[i-1], A[i])<br>
                swapped := true<br>
                end if<br>
                end for<br>
                until not swapped<br>
                end procedure
                <br><br>

                Optimizing bubble sort<br>
                procedure bubbleSort(A : list of sortable items)<br>
                n := length(A)<br>
                repeat<br>
                newn := 0<br>
                for i := 1 to n - 1 inclusive do<br>
                if A[i - 1] > A[i] then<br>
                swap(A[i - 1], A[i])<br>
                newn := i<br>
                end if<br>
                end for<br>
                n := newn<br>
                until n ≤ 1<br>
                end procedure
                <br><br>
                The worst-case and average complexity of bubble sort is O(n2), where n is the number of objects to be
                sorted. Most practical sorting algorithms have far lower worst-case or average complexity, frequently O.
                (n log n). Other (n2) sorting algorithms, such as insertion sort, are often quicker than bubble sort and
                no more difficult. As a result, bubble sort is not a useful sorting algorithm.<br><br>

                The sole important benefit that bubble sort has over most other algorithms, including quicksort but not
                insertion sort, is that the ability to discover efficient list sorting is incorporated into the
                algorithm. The complexity of bubble sort is only O when the list is already sorted (best-case) (n). Most
                other algorithms, even ones with lower average-case complexity, run their whole sorting operation on the
                set, making them more complicated.<br><br>
            </p>

            <h4 class="mb-4">Insertion Sort</h4>
            <p class="text-lg mb-5">
                Insertion sort is a straightforward sorting algorithm that constructs the final sorted array (or list)
                one item at a time. On huge lists, it is substantially less efficient than more complex algorithms such
                as quicksort, heapsort, or merge sort. However, insertion sort has a number of benefits like stability,
                adaptability, simple implementation and efficiency on small datasets.
                <br><br>

                Iteratively, insertion sort consumes one input element every iteration and generates a sorted output
                list. Insertion sort takes one element from the input data at each iteration, locates its place inside
                the sorted list, and inserts it there. It is repeated until no input items are left.
                <br><br>

                Sorting is usually done in-place by iterating through the array and building the sorted list behind it.
                It compares the value at each array place to the biggest value in the sorted list (which happens to be
                next to it, in the previous array-position checked). If the element is larger, it remains in place and
                passes on to the next. If the value is smaller, it finds the suitable location inside the sorted list,
                moves all the bigger values up to produce a space, and inserts into that space.
                <br><br>

                The most common variant of insertion sort, which operates on arrays, can be described as follows:<br>

                1. Suppose there exists a function called Insert designed to insert a value into a sorted sequence at
                the
                beginning of an array. It operates by beginning at the end of the sequence and shifting each element one
                place to the right until a suitable position is found for the new element. The function has the side
                effect of overwriting the value stored immediately after the sorted sequence in the array.<br>
                2. To perform an insertion sort, begin at the left-most element of the array and invoke Insert to insert
                each element encountered into its correct position. The ordered sequence into which the element is
                inserted is stored at the beginning of the array in the set of indices already examined. Each insertion
                overwrites a single value: the value being inserted.
                <br><br>

                Pseudocode can be written as:<br>
                i ← 1<br>
                while i less than length(A)<br>
                j ← i while j> 0 and A[j-1] > A[j]<br>
                swap A[j] and A[j-1]<br>
                j ← j - 1<br>
                end while<br>
                i ← i + 1<br>
                end while
                <br><br>

                Function Implementation:<br>
                function insertionSortR(array A, int n)<br>
                if n > 0<br>
                insertionSortR(A, n-1)<br>
                x ← A[n]<br>
                j ← n-1<br>
                while j >= 0 and A[j] > x<br>
                A[j+1] ← A[j]<br>
                j ← j-1<br>
                end while<br>
                A[j+1] ← x<br>
                end if<br>
                end function
                <br><br>
                The best-case scenario input is a pre-sorted array. Insertion sort has a linear running time in this
                instance (i.e., O(n)). During each iteration, just the first remaining element of the input is compared
                to the right-most element of the array's sorted subsection.
                <br><br>
                The most basic worst-case scenario input is an array sorted in reverse order. The set of all worst-case
                inputs consists of all arrays in which each member is the smallest or second-smallest of the items
                preceding it. In these circumstances, each inner loop iteration will scan and move the whole sorted
                portion of the array before inserting the next element. This results in an insertion sort with a
                quadratic running time (i.e., O(n<sup>2</sup>).<br><br>
            </p>
            <h4 class="mb-4">Quick Sort</h4>
            <p class="text-lg mb-5">
                Quicksort is a sorting algorithm that works in-place. When properly implemented, it can be somewhat
                quicker than merge sort and two or three times faster than heapsort. <br><br>
                Quicksort employs a divide-and-conquer strategy. It works by picking a 'pivot' element from the array
                and dividing the other
                items into two sub-arrays based on whether they are less than or greater than the pivot. As a result, it
                is also known as partition-exchange sort. After that, the sub-arrays are sorted recursively. This may be
                done in-place, using only a little amount of additional RAM to do the sorting.<br><br>

                Quicksort is a comparison sort, which means it may sort objects of any type using a "less-than"
                connection. Efficient Quicksort implementations are not a stable sort. <br><br>

                Quicksort's mathematical examination reveals that, on average, the method takes O(nlog(n)) comparisons
                to sort n objects. In the worst-case scenario, it performs O(n<sup>2</sup>) comparisons.<br><br>

                The steps for in-place quicksort are: <br>

                1. If the range has less than two elements, return immediately as there is nothing to do. Possibly for
                other very short lengths a special-purpose sorting method is applied and the remainder of these steps
                skipped.<br>
                2. Otherwise pick a value, called a pivot, that occurs in the range (the precise manner of choosing
                depends
                on the partition routine, and can involve randomness).<br>
                3. Partition the range: reorder its elements, while determining a point of division, so that all
                elements
                with values less than the pivot come before the division, while all elements with values greater than
                the pivot come after it; elements that are equal to the pivot can go either way. Since at least one
                instance of the pivot is present, most partition routines ensure that the value that ends up at the
                point of division is equal to the pivot, and is now in its final position (but termination of quicksort
                does not depend on this, as long as sub-ranges strictly smaller than the original are produced). <br>
                4. Recursively apply the quicksort to the sub-range up to the point of division and to the sub-range
                after
                it, possibly excluding from both ranges the element equal to the pivot at the point of division. (If the
                partition produces a possibly larger sub-range near the boundary where all elements are known to be
                equal to the pivot, these can be excluded as well.)<br><br>
                Pseudocode:<br>
                // Sorts a (portion of an) array, divides it into partitions, then sorts those
                algorithm quicksort(A, lo, hi) is<br>
                // If indices are in correct order<br>
                if lo >= 0 && hi >= 0 && lo less than hi then<br>
                // Partition array and get pivot index<br>
                p := partition(A, lo, hi)<br><br>

                // Sort the two partitions<br>
                quicksort(A, lo, p - 1) // Left side of pivot<br>
                quicksort(A, p + 1, hi) // Right side of pivot<br>

                // Divides array into two partitions<br>
                algorithm partition(A, lo, hi) is<br>
                pivot := A[hi] // The pivot must be the last element<br><br>

                // Pivot index<br>
                i := lo - 1<br><br>

                for j := lo to hi do<br>
                // If the current element is less than or equal to the pivot<br>
                if A[j] less than equal to pivot then<br>
                // Move the pivot index forward<br>
                i := i + 1<br><br>

                // Swap the current element with the element at the pivot<br>
                swap A[i] with A[j]<br>
                return i // the pivot index<br><br>

                When one of the sublists provided by the partitioning procedure is of size n 1, the partition is the
                most imbalanced. [30] This can happen if the pivot is the smallest or biggest member in the list, or in
                some implementations (for example, the Lomuto partition technique mentioned above) when all the items
                are equal.
                <br><br>

                If this occurs again in each partition, then each recursive call processes a list with a length one less
                than the preceding list. As a result, we may make n 1 nested calls before reaching a list of size 1.
                This signifies that the call tree is a nested chain of n 1 calls. Then there's the insertion sort, which
                takes O(n<sup>2</sup>) time.
                <br><br>

                Quicksort takes O(n log n) time in expectation to sort an array of n unique elements, averaged across
                all n! permutations of n elements with equal probability.
                <br><br>
            </p>
            <!-- </div>
            </div> -->
        </div>
    </div>


    <script src="../../assets/js/jquery-3.5.1.min.js"></script>

    <script src="../../assets/js/bootstrap.bundle.min.js"></script>

    <script src="../../assets/vendor/wow/wow.min.js"></script>

    <script src="../../assets/vendor/owl-carousel/js/owl.carousel.min.js"></script>

    <script src="../../assets/vendor/waypoints/jquery.waypoints.min.js"></script>

    <script src="../../assets/vendor/animateNumber/jquery.animateNumber.min.js"></script>

    <script src="../../assets/js/google-maps.js"></script>

    <script src="../../assets/js/theme.js"></script>


</body>

</html>